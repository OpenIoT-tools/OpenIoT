// Code generated by mockery v2.53.3. DO NOT EDIT.

package mocks

import (
	entity "github.com/OpenIoT-tools/OpenIoT/internal/core/models/entity"
	mock "github.com/stretchr/testify/mock"
)

// DeviceRespository is an autogenerated mock type for the DeviceRespository type
type DeviceRespository struct {
	mock.Mock
}

type DeviceRespository_Expecter struct {
	mock *mock.Mock
}

func (_m *DeviceRespository) EXPECT() *DeviceRespository_Expecter {
	return &DeviceRespository_Expecter{mock: &_m.Mock}
}

// CreateDevice provides a mock function with given fields: device
func (_m *DeviceRespository) CreateDevice(device *entity.Device) (*entity.Device, error) {
	ret := _m.Called(device)

	if len(ret) == 0 {
		panic("no return value specified for CreateDevice")
	}

	var r0 *entity.Device
	var r1 error
	if rf, ok := ret.Get(0).(func(*entity.Device) (*entity.Device, error)); ok {
		return rf(device)
	}
	if rf, ok := ret.Get(0).(func(*entity.Device) *entity.Device); ok {
		r0 = rf(device)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*entity.Device)
		}
	}

	if rf, ok := ret.Get(1).(func(*entity.Device) error); ok {
		r1 = rf(device)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeviceRespository_CreateDevice_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateDevice'
type DeviceRespository_CreateDevice_Call struct {
	*mock.Call
}

// CreateDevice is a helper method to define mock.On call
//   - device *entity.Device
func (_e *DeviceRespository_Expecter) CreateDevice(device interface{}) *DeviceRespository_CreateDevice_Call {
	return &DeviceRespository_CreateDevice_Call{Call: _e.mock.On("CreateDevice", device)}
}

func (_c *DeviceRespository_CreateDevice_Call) Run(run func(device *entity.Device)) *DeviceRespository_CreateDevice_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(*entity.Device))
	})
	return _c
}

func (_c *DeviceRespository_CreateDevice_Call) Return(_a0 *entity.Device, _a1 error) *DeviceRespository_CreateDevice_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *DeviceRespository_CreateDevice_Call) RunAndReturn(run func(*entity.Device) (*entity.Device, error)) *DeviceRespository_CreateDevice_Call {
	_c.Call.Return(run)
	return _c
}

// FindDeviceById provides a mock function with given fields: deviceId
func (_m *DeviceRespository) FindDeviceById(deviceId string) (*entity.Device, error) {
	ret := _m.Called(deviceId)

	if len(ret) == 0 {
		panic("no return value specified for FindDeviceById")
	}

	var r0 *entity.Device
	var r1 error
	if rf, ok := ret.Get(0).(func(string) (*entity.Device, error)); ok {
		return rf(deviceId)
	}
	if rf, ok := ret.Get(0).(func(string) *entity.Device); ok {
		r0 = rf(deviceId)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*entity.Device)
		}
	}

	if rf, ok := ret.Get(1).(func(string) error); ok {
		r1 = rf(deviceId)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeviceRespository_FindDeviceById_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'FindDeviceById'
type DeviceRespository_FindDeviceById_Call struct {
	*mock.Call
}

// FindDeviceById is a helper method to define mock.On call
//   - deviceId string
func (_e *DeviceRespository_Expecter) FindDeviceById(deviceId interface{}) *DeviceRespository_FindDeviceById_Call {
	return &DeviceRespository_FindDeviceById_Call{Call: _e.mock.On("FindDeviceById", deviceId)}
}

func (_c *DeviceRespository_FindDeviceById_Call) Run(run func(deviceId string)) *DeviceRespository_FindDeviceById_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string))
	})
	return _c
}

func (_c *DeviceRespository_FindDeviceById_Call) Return(_a0 *entity.Device, _a1 error) *DeviceRespository_FindDeviceById_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *DeviceRespository_FindDeviceById_Call) RunAndReturn(run func(string) (*entity.Device, error)) *DeviceRespository_FindDeviceById_Call {
	_c.Call.Return(run)
	return _c
}

// ListDevicesByCategory provides a mock function with given fields: categoryId
func (_m *DeviceRespository) ListDevicesByCategory(categoryId string) ([]*entity.Device, error) {
	ret := _m.Called(categoryId)

	if len(ret) == 0 {
		panic("no return value specified for ListDevicesByCategory")
	}

	var r0 []*entity.Device
	var r1 error
	if rf, ok := ret.Get(0).(func(string) ([]*entity.Device, error)); ok {
		return rf(categoryId)
	}
	if rf, ok := ret.Get(0).(func(string) []*entity.Device); ok {
		r0 = rf(categoryId)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*entity.Device)
		}
	}

	if rf, ok := ret.Get(1).(func(string) error); ok {
		r1 = rf(categoryId)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeviceRespository_ListDevicesByCategory_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListDevicesByCategory'
type DeviceRespository_ListDevicesByCategory_Call struct {
	*mock.Call
}

// ListDevicesByCategory is a helper method to define mock.On call
//   - categoryId string
func (_e *DeviceRespository_Expecter) ListDevicesByCategory(categoryId interface{}) *DeviceRespository_ListDevicesByCategory_Call {
	return &DeviceRespository_ListDevicesByCategory_Call{Call: _e.mock.On("ListDevicesByCategory", categoryId)}
}

func (_c *DeviceRespository_ListDevicesByCategory_Call) Run(run func(categoryId string)) *DeviceRespository_ListDevicesByCategory_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string))
	})
	return _c
}

func (_c *DeviceRespository_ListDevicesByCategory_Call) Return(_a0 []*entity.Device, _a1 error) *DeviceRespository_ListDevicesByCategory_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *DeviceRespository_ListDevicesByCategory_Call) RunAndReturn(run func(string) ([]*entity.Device, error)) *DeviceRespository_ListDevicesByCategory_Call {
	_c.Call.Return(run)
	return _c
}

// ListDevicesById provides a mock function with given fields: devicesId
func (_m *DeviceRespository) ListDevicesById(devicesId ...string) ([]*entity.Device, error) {
	_va := make([]interface{}, len(devicesId))
	for _i := range devicesId {
		_va[_i] = devicesId[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListDevicesById")
	}

	var r0 []*entity.Device
	var r1 error
	if rf, ok := ret.Get(0).(func(...string) ([]*entity.Device, error)); ok {
		return rf(devicesId...)
	}
	if rf, ok := ret.Get(0).(func(...string) []*entity.Device); ok {
		r0 = rf(devicesId...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*entity.Device)
		}
	}

	if rf, ok := ret.Get(1).(func(...string) error); ok {
		r1 = rf(devicesId...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeviceRespository_ListDevicesById_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListDevicesById'
type DeviceRespository_ListDevicesById_Call struct {
	*mock.Call
}

// ListDevicesById is a helper method to define mock.On call
//   - devicesId ...string
func (_e *DeviceRespository_Expecter) ListDevicesById(devicesId ...interface{}) *DeviceRespository_ListDevicesById_Call {
	return &DeviceRespository_ListDevicesById_Call{Call: _e.mock.On("ListDevicesById",
		append([]interface{}{}, devicesId...)...)}
}

func (_c *DeviceRespository_ListDevicesById_Call) Run(run func(devicesId ...string)) *DeviceRespository_ListDevicesById_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]string, len(args)-0)
		for i, a := range args[0:] {
			if a != nil {
				variadicArgs[i] = a.(string)
			}
		}
		run(variadicArgs...)
	})
	return _c
}

func (_c *DeviceRespository_ListDevicesById_Call) Return(_a0 []*entity.Device, _a1 error) *DeviceRespository_ListDevicesById_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *DeviceRespository_ListDevicesById_Call) RunAndReturn(run func(...string) ([]*entity.Device, error)) *DeviceRespository_ListDevicesById_Call {
	_c.Call.Return(run)
	return _c
}

// RemoveDevice provides a mock function with given fields: deviceId
func (_m *DeviceRespository) RemoveDevice(deviceId string) error {
	ret := _m.Called(deviceId)

	if len(ret) == 0 {
		panic("no return value specified for RemoveDevice")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(string) error); ok {
		r0 = rf(deviceId)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// DeviceRespository_RemoveDevice_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RemoveDevice'
type DeviceRespository_RemoveDevice_Call struct {
	*mock.Call
}

// RemoveDevice is a helper method to define mock.On call
//   - deviceId string
func (_e *DeviceRespository_Expecter) RemoveDevice(deviceId interface{}) *DeviceRespository_RemoveDevice_Call {
	return &DeviceRespository_RemoveDevice_Call{Call: _e.mock.On("RemoveDevice", deviceId)}
}

func (_c *DeviceRespository_RemoveDevice_Call) Run(run func(deviceId string)) *DeviceRespository_RemoveDevice_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string))
	})
	return _c
}

func (_c *DeviceRespository_RemoveDevice_Call) Return(_a0 error) *DeviceRespository_RemoveDevice_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *DeviceRespository_RemoveDevice_Call) RunAndReturn(run func(string) error) *DeviceRespository_RemoveDevice_Call {
	_c.Call.Return(run)
	return _c
}

// UpdateHardware provides a mock function with given fields: device
func (_m *DeviceRespository) UpdateHardware(device *entity.Device) (*entity.Device, error) {
	ret := _m.Called(device)

	if len(ret) == 0 {
		panic("no return value specified for UpdateHardware")
	}

	var r0 *entity.Device
	var r1 error
	if rf, ok := ret.Get(0).(func(*entity.Device) (*entity.Device, error)); ok {
		return rf(device)
	}
	if rf, ok := ret.Get(0).(func(*entity.Device) *entity.Device); ok {
		r0 = rf(device)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*entity.Device)
		}
	}

	if rf, ok := ret.Get(1).(func(*entity.Device) error); ok {
		r1 = rf(device)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeviceRespository_UpdateHardware_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdateHardware'
type DeviceRespository_UpdateHardware_Call struct {
	*mock.Call
}

// UpdateHardware is a helper method to define mock.On call
//   - device *entity.Device
func (_e *DeviceRespository_Expecter) UpdateHardware(device interface{}) *DeviceRespository_UpdateHardware_Call {
	return &DeviceRespository_UpdateHardware_Call{Call: _e.mock.On("UpdateHardware", device)}
}

func (_c *DeviceRespository_UpdateHardware_Call) Run(run func(device *entity.Device)) *DeviceRespository_UpdateHardware_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(*entity.Device))
	})
	return _c
}

func (_c *DeviceRespository_UpdateHardware_Call) Return(_a0 *entity.Device, _a1 error) *DeviceRespository_UpdateHardware_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *DeviceRespository_UpdateHardware_Call) RunAndReturn(run func(*entity.Device) (*entity.Device, error)) *DeviceRespository_UpdateHardware_Call {
	_c.Call.Return(run)
	return _c
}

// UpdateTargetVersion provides a mock function with given fields: device
func (_m *DeviceRespository) UpdateTargetVersion(device ...*entity.Device) ([]*entity.Device, error) {
	_va := make([]interface{}, len(device))
	for _i := range device {
		_va[_i] = device[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateTargetVersion")
	}

	var r0 []*entity.Device
	var r1 error
	if rf, ok := ret.Get(0).(func(...*entity.Device) ([]*entity.Device, error)); ok {
		return rf(device...)
	}
	if rf, ok := ret.Get(0).(func(...*entity.Device) []*entity.Device); ok {
		r0 = rf(device...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*entity.Device)
		}
	}

	if rf, ok := ret.Get(1).(func(...*entity.Device) error); ok {
		r1 = rf(device...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeviceRespository_UpdateTargetVersion_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdateTargetVersion'
type DeviceRespository_UpdateTargetVersion_Call struct {
	*mock.Call
}

// UpdateTargetVersion is a helper method to define mock.On call
//   - device ...*entity.Device
func (_e *DeviceRespository_Expecter) UpdateTargetVersion(device ...interface{}) *DeviceRespository_UpdateTargetVersion_Call {
	return &DeviceRespository_UpdateTargetVersion_Call{Call: _e.mock.On("UpdateTargetVersion",
		append([]interface{}{}, device...)...)}
}

func (_c *DeviceRespository_UpdateTargetVersion_Call) Run(run func(device ...*entity.Device)) *DeviceRespository_UpdateTargetVersion_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]*entity.Device, len(args)-0)
		for i, a := range args[0:] {
			if a != nil {
				variadicArgs[i] = a.(*entity.Device)
			}
		}
		run(variadicArgs...)
	})
	return _c
}

func (_c *DeviceRespository_UpdateTargetVersion_Call) Return(_a0 []*entity.Device, _a1 error) *DeviceRespository_UpdateTargetVersion_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *DeviceRespository_UpdateTargetVersion_Call) RunAndReturn(run func(...*entity.Device) ([]*entity.Device, error)) *DeviceRespository_UpdateTargetVersion_Call {
	_c.Call.Return(run)
	return _c
}

// UpdateVersion provides a mock function with given fields: device
func (_m *DeviceRespository) UpdateVersion(device *entity.Device) (*entity.Device, error) {
	ret := _m.Called(device)

	if len(ret) == 0 {
		panic("no return value specified for UpdateVersion")
	}

	var r0 *entity.Device
	var r1 error
	if rf, ok := ret.Get(0).(func(*entity.Device) (*entity.Device, error)); ok {
		return rf(device)
	}
	if rf, ok := ret.Get(0).(func(*entity.Device) *entity.Device); ok {
		r0 = rf(device)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*entity.Device)
		}
	}

	if rf, ok := ret.Get(1).(func(*entity.Device) error); ok {
		r1 = rf(device)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeviceRespository_UpdateVersion_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdateVersion'
type DeviceRespository_UpdateVersion_Call struct {
	*mock.Call
}

// UpdateVersion is a helper method to define mock.On call
//   - device *entity.Device
func (_e *DeviceRespository_Expecter) UpdateVersion(device interface{}) *DeviceRespository_UpdateVersion_Call {
	return &DeviceRespository_UpdateVersion_Call{Call: _e.mock.On("UpdateVersion", device)}
}

func (_c *DeviceRespository_UpdateVersion_Call) Run(run func(device *entity.Device)) *DeviceRespository_UpdateVersion_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(*entity.Device))
	})
	return _c
}

func (_c *DeviceRespository_UpdateVersion_Call) Return(_a0 *entity.Device, _a1 error) *DeviceRespository_UpdateVersion_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *DeviceRespository_UpdateVersion_Call) RunAndReturn(run func(*entity.Device) (*entity.Device, error)) *DeviceRespository_UpdateVersion_Call {
	_c.Call.Return(run)
	return _c
}

// NewDeviceRespository creates a new instance of DeviceRespository. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewDeviceRespository(t interface {
	mock.TestingT
	Cleanup(func())
}) *DeviceRespository {
	mock := &DeviceRespository{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
